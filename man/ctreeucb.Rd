% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ctreeucb.R
\name{ctreeucb}
\alias{ctreeucb}
\title{ctreeucb agorithm}
\usage{
ctreeucb(
  dt,
  visitor_reward,
  K = ncol(visitor_reward),
  ctree_parameters_control = ctreeucb_parameters_control_default(dt, visitor_reward)
)
}
\arguments{
\item{dt}{Dataframe of integer numeric or factor values}

\item{visitor_reward}{Dataframe of integer or numeric values}

\item{is_reward_are_boolean}{logical value (optional)}

\item{learn_size}{number of items dedicated to the learnset (step 1) (optional),}

\item{arm_for_learn}{arm dedicated to the learnset (step 1) (optional),}

\item{explanatory_variable}{= list of covariates (optional),}

\item{ctree_control_val}{= Various parameters that control aspects of the ‘ctree’ fit (optional),}
}
\value{
\itemize{ List of element:
 \item choice: choices of UCB,
 \item proba: probability of the chosen arms,
 \item time: time of cumputation,
 \item theta_hat: coefficients estimated of each arm
 \item theta: real coefficients of each arm
 }
}
\description{
ctreeucb automatically create homogeneous groups by a conditional inference method (see  \code{\link{ctree}}) in a collection and processing step before the A/B test (step 1).
These groups are created according to the objective of the test using information from previous items (obtained rewards, items characteristics, temporal information, \ldots).
This information comes from the items that have already been subjected to the original variation (A),
implemented before the test. In the A/B test period (step 2), the method defines as many non-contextual bandits  (see  \code{\link{UCB}}) as there are groups.
Each bandit aims to find the optimal variation associated to its group.
So, a new item is firstly classed into a group and then the associated bandit chooses the variation to which the item must be affected.
}
\examples{
size.tot = 1000
set.seed(4649)                          # this makes the example exactly reproducible
x1 = runif(size.tot, min=0, max=10)          # you have 4, largely uncorrelated predictors
x2 = runif(size.tot, min=0, max=10)
x3 = runif(size.tot, min=0, max=10)
x4 = runif(size.tot, min=0, max=10)
dt = cbind(x1,x2,x3,x4)
arm_1 <-  as.vector(c(-1,9,-8,4))
K1 = crossprod(t(dt),arm_1)
arm_2 <-  as.vector(c(-1,2,1,0))
K2 = crossprod(t(dt),arm_2)
arm_3 <-  as.vector(c(-1,-5,1,10))
K3 = crossprod(t(dt),arm_3)
visitor_reward <-  data.frame(K1,K2,K3)
dt <- as.data.frame(dt)
size.tot = 1000
temp <- ctreeucb(dt,visitor_reward)
}
